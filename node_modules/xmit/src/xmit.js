
/** 
 * 	@class 
 * 	Not tested yet.. do not use 
 */




var log = require("dicey_debug").log;

var Channel = require("./channel_atom");


function __Xmit(context, name) { 

	var _name, _channels, _channel_names;

	function Xmit(context, name, ChannelType) { 
		Channel = ChannelType||Channel;
		
		this.name = _name =  name || "no name xmitter";
		_ctx = context===true? this : context;
		_channels = {};
		_channel_names = [];
	}

	function _xmit(ts, channel_name, msg) { 
		if (channel_name in _channels === false) return false;
		_channels[channel_name].xmit(msg);
		return ts;
	}

	function _on(ts, channel_name, lambda, ctx) { 
		if (channel_name in _channels === false) { 
			this.add(channel_name, Channel);
		}
		_channels[channel_name].on(lambda, ctx);
		return ts;
	}

	function _when(ts, channel_name, condition, lambda, ctx) { 
		_on(channel_name, function(msg) { 
			if (condition(msg) === false) return;
			return lambda.apply(ctx, msg);
		});
		return ts;
	}

	function _chain(ts, channel_name, out_channel_name) { 
		_on(channel_name, function(msg) { 
			ts._xmit(out_channel_name, msg);
		});
		return ts;
	}

	function _chainWhen(ts, channel_name, condition, out_channel_name) { 
		_on(channel_name, function(msg) { 
			if (condition(msg) === false) return ;
			ts._xmit(out_channel_name, msg)
		});
		return ts;
	}

	function _add(name, channelType) { 
		if (name in _channels === true) return;
		var rt = _channels[name] = new channelType(name, _ctx);
		_channel_names.push(name);
		return rt;
	}


	Xmit.prototype = { 
		add:function(name, channelType) { 
			_add(name, channelType||Channel);
			return this;
			// make this a safe function 
			// if (name in _channels ===true) return;
			// _channels[name] = new (channelType || Channel)(name, _ctx);
			// _channel_names.push(name);
			// return this;
		},
		addChannel:function(name, channelType) { 
			return _add(name, channelType || Channel);
		},
		on:function(channel_name, lambda, ctx) {
			return _on(this, channel_name, lambda, ctx||_ctx);
		},
		when:function(channel_name, condition, lambda, ctx) { 
			return _when(ts, channel_name, condition, lambda, ctx||_ctx)
		},
		xmit:function(channel_name, msg) { 
			return _xmit(this, channel_name, msg);
		},
		xmitIf:function(channel_name, condition, msg) { 
			if (condition===true) _xmit(this, channel_name, msg);
		},
		chain:function(channel_name, out_channel_name) {
			return _chain(this, channel_name, out_channel_name);
		},
		chainTo:function(channel_name, lambda, out_channel_name) { 
			_on(channel_name, 
				function() {
					_xmit(out_channel_name, lambda(msg));
				}
			);
		},
		chainWhen:function(channel_name, condition, out_channel_name) { 
			return _chainWhen(this, channel_name, condition, out_channel_name);
			_when(channel_name, condition, function(msg) { 
				_xmit(this, out_channel_name, msg);
			});
		},
		toString:function() { 
			return "XMIT_ATOM : " + _name;
		}
	}	

	return new Xmit(context, name);
}


module.exports = __Xmit;

