/** 
 *	@class Xmit
 *  	@description Xmit is the like the 
 *  	xmitter available. 
 *  In has no assertions or error checking.. 
 *  There is also no remove listener function;
 * 	<br>
 *  NOTE about function nomenclature: <br>
 * 		prototype._funcName = a private function <br>
 * 		prototype.funcName will return the Xmit instance<br>
 * 		prototype.funcName_ will return the object the function creates.<br>
 * 			eg: on_(event_name, lambda) will return lambda
 * 				on(event_name, lambda) will return xmit instance<br>
 *	<br>
 * 	Default Channel is an Atom Channel version ... It is 
 * 	meant to be a default when no channel type is specified
*/



'use strict';

var XmitAtom = require("./xmit_atom"),
		XAP = XmitAtom.prototype;
	Channel = require("./channel_atom");

function Xmit(context, name, channelType) { 
	if (typeof(context) !== "object") throw new Error(INVALID_CONTEXT);
	if (typeof(name) !== "string") throw new Error(INVALID_NAME);
	if (channelType.prototype.FAMILY !== "XMIT_CHANNEL", throw new Error(INVALI)
}

Xmit.prototype._xmit = XmitAtom.prototype.xmit;

Xmit.prototype.xmit = function(channel_name, msg) { 
	assert(channel_name in this._channels === true, 
		UNDEFINED_CHANNEL);
	return this._xmit(channel_name, msg);
}




Xmit.prototype._on_ = XAP.on_;

Xmit.prototype.on_ = function(channel_name, lambda, context) { 
	assert(typeof(channel_name)==="string", INVALID_CHANNEL_NAME);
	assert(typeof(lambda)==="function", INVALID_LAMBDA);
	assert(typeof(context)==="object", INVALID_CONTEXT);
	return this._on(channel_name, lambda, context);
}

Xmit.prototype.on = XAP.on;



Xmit.prototype._add_ = XAP.add_;

Xmit.prototype.add = function(name, channelType, context) { 
	assert(typeof(name)==="string", INVALID_CHANNEL_NAME);
	
}


	function _add(name, channelType) { 
		if (name in _channels === true) return;
		var rt = _channels[name] = new channelType(name, _ctx);
		_channel_names.push(name);
		return rt;
	}


	Xmit.prototype = { 
		add:function(name, channelType) { 
			_add(name, channelType||Channel);
			return this;
			// make this a safe function 
			// if (name in _channels ===true) return;
			// _channels[name] = new (channelType || Channel)(name, _ctx);
			// _channel_names.push(name);
			// return this;
		},
		addChannel:function(name, channelType) { 
			return _add(name, channelType || Channel);
		},
		on:function(channel_name, lambda, ctx) {
			return _on(this, channel_name, lambda, ctx||_ctx);
		},
		when:function(channel_name, condition, lambda, ctx) { 
			return _when(ts, channel_name, condition, lambda, ctx||_ctx)
		},
		xmit:function(channel_name, msg) { 
			return _xmit(this, channel_name, msg);
		},
		xmitIf:function(channel_name, condition, msg) { 
			if (condition===true) _xmit(this, channel_name, msg);
		},
		chain:function(channel_name, out_channel_name) {
			return _chain(this, channel_name, out_channel_name);
		},
		chainTo:function(channel_name, lambda, out_channel_name) { 
			_on(channel_name, 
				function() {
					_xmit(out_channel_name, lambda(msg));
				}
			);
		},
		chainWhen:function(channel_name, condition, out_channel_name) { 
			return _chainWhen(this, channel_name, condition, out_channel_name);
			_when(channel_name, condition, function(msg) { 
				_xmit(this, out_channel_name, msg);
			});
		},
		toString:function() { 
			return "XMIT_ATOM : " + _name;
		}
	}	

	return new Xmit(context, name);
}


module.exports = __Xmit;

